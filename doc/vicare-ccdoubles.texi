\input texinfo.tex
@c %**start of header
@setfilename vicare-ccdoubles.info
@settitle CCDoubles for Vicare
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCDoubles for Vicare

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/@ccdoubles{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-ccdoubles

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2015

@c ------------------------------------------------------------

@set FOREIGN_PACKAGE            @ccdoubles{}
@set FOREIGN_VERSION            0.1d2
@set FOREIGN_URL                @url{http://github.com/marcomaggi/ccdoubles}
@set FOREIGN_SCHEME_LIB         @library{vicare math ccdoubles}
@c @set NAUSICAA_SCHEME_LIB        @library{nausicaa math ccdoubles}
@set GITHUB_URL                 @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{http://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}
@set VICARE_HOMEPAGE_URL        @url{http://marcomaggi.github.io/vicare.html}

@macro ccdoublesref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,ccdoubles}
@end macro

@macro ccdoubles{}
@acronym{CCDoubles}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the
@value{FOREIGN_PACKAGE} C language library.  @value{PACKAGE} makes use
of the Foreign Functions Interface (@ffi{}) provided by Vicare Scheme.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
@value{FOREIGN_PACKAGE} is available at:

@center @value{FOREIGN_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-ccdoubles: (vicare-ccdoubles). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* plain::                       Plain programming interface.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of
Scheme language libraries for Vicare Scheme; it provides bindings for
the @value{FOREIGN_PACKAGE} C language library.  @value{PACKAGE} makes
use of the Foreign Functions Interface (@ffi{}) provided by Vicare
Scheme.

The last time the author bothered to update this paragraph, he had
tested @value{FOREIGN_PACKAGE} version @value{FOREIGN_VERSION}; the
@value{FOREIGN_PACKAGE} library is available at:

@center @value{FOREIGN_URL}

The package installs a Scheme library @value{FOREIGN_SCHEME_LIB} which
exports one binding for each @value{FOREIGN_PACKAGE} public function.

The following Scheme libraries are installed:

@table @asis
@item @library{vicare math ccdoubles}
@cindex Library @library{vicare math ccdoubles}
@cindex @library{vicare math ccdoubles}, library
It exports one binding for each @value{FOREIGN_PACKAGE} public function;
it implements a high--level @api{}.  All the Scheme function names are
directly derived from the C function names by replacing underscore
characters @samp{_} with dash characters @samp{-}; so
@cfunc{ccdoubles_real_vector_log} becomes
@func{ccdoubles-real-vector-log}.

@item @library{vicare math ccdoubles functions}
@cindex Library @library{vicare math ccdoubles functions}
@cindex @library{vicare math ccdoubles functions}, library
It exports one syntactic binding for each @value{FOREIGN_PACKAGE} public
function.  All the Scheme function names are equal to the C function
names.
@end table

Scheme libraries are installed under the directory:

@center @file{$(libdir)/vicare-scheme}

This document contains only a brief description of the functions: refer
to the @value{FOREIGN_PACKAGE}'s documentation for details.

@c page
@node plain
@chapter Plain programming interface


@cindex Library @value{FOREIGN_SCHEME_LIB}
@cindex @value{FOREIGN_SCHEME_LIB}, library


The library @value{FOREIGN_SCHEME_LIB} implements the high level @api{}
for @value{FOREIGN_PACKAGE}.  All the indexes are zero--based.

@menu
* plain version::               @value{FOREIGN_PACKAGE} version informations.
* plain rvec::                  Real vectors of flonums.
* plain cvec::                  Complex vectors of flonums.
* plain rmat::                  Real matrices of flonums.
* plain cmat::                  Complex matrices of flonums.
* plain ivec::                  Real vectors of integers.
* plain imat::                  Real matrices of integers.
@end menu

@c page
@node plain version
@section @value{FOREIGN_PACKAGE} version informations


The installed C library follows version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.

The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-version-interface-current
@defunx ccdoubles-version-interface-revision
@defunx ccdoubles-version-interface-age
Return a fixnum representing a version number.
@end defun


@defun ccdoubles-version-string
Return a Scheme string representing the version number.
@end defun

@c page
@node plain rvec
@section Real vectors of flonums


@menu
* plain rvec struct::           Real vector data type.
* plain rvec init::             Initialisation and finalisation.
* plain rvec access::           Setters and getters.
* plain rvec conversion::       Object types conversion.
* plain rvec basic::            Basic vector operations.
@end menu

@c page
@node plain rvec struct
@subsection Real vector data type


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@deftp {Struct Type} ccdoubles-real-vector
@cindex Argument @var{rvec}
@cindex @var{rvec} argument
Opaque structure type referencing a data area holding @samp{double}
precision flonums.  Unless otherwise specified, when instances of this
type are used as arguments to functions: this documentation identifies
them as @var{rvec}.

Instances of this type must be finalised with
@func{ccdoubles-real-vector-finalise}; whenever an instance of this type
is garbage collected: @func{ccdoubles-real-vector-finalise} is
automatically applied to it and any error ignored.

In certain contexts, instances of this type own the underlying data
area, in other contexts they do not:

@itemize
@item
Finalising a @objtype{ccdoubles-real-vector} instance owning the data
area, causes finalisation of the data area too.

@item
Finalising a @objtype{ccdoubles-real-vector} instance @strong{not}
owning the data area, leaves the data area untouched.
@end itemize

@noindent
this should happen transparently.
@end deftp


@defun ccdoubles-real-vector? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-real-vector}; otherwise return @false{}.
@end defun


@defun ccdoubles-real-vector?/alive @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-real-vector} and it has not been finalised; return
@false{} otherwise.
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun ccdoubles-real-vector-putprop @var{rvec} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{rvec};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun ccdoubles-real-vector-getprop @var{rvec} @var{key}
Return the value of the property @var{key} in the property list of
@var{rvec}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun ccdoubles-real-vector-remprop @var{rvec} @var{key}
Remove the property @var{key} from the property list of @var{rvec}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun ccdoubles-real-vector-property-list @var{rvec}
Return a new association list representing the property list of
@var{rvec}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Custom destructor


@defun alpha-custom-destructor @var{rvec}
@defunx set-alpha-custom-destructor! @var{rvec} @var{func}
Retrieve or set a destructor function associated to @var{rvec}.

Whenever @var{rvec} is finalised, either explicitly with
@func{ccdoubles-real-vector-finalise} or implicitly by the garbage
collector, @var{func} is applied to @var{rvec} before the internal state
of @var{rvec} is destroyed.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun ccdoubles-real-vector-hash @var{rvec}
Return an exact integer to be used as hashtable key for @var{rvec}.
Hashtables having a @objtype{ccdoubles-real-vector} as key can be instantiated
as follows:

@example
(make-hashtable ccdoubles-real-vector-hash eq?)
@end example
@end defun

@c page
@node plain rvec init
@subsection Initialisation and finalisation


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector-initialise @var{nslots}
Build and return a new @objtype{ccdoubles-real-vector} object; if an
error occurs raise an exception.  @var{nslots} must be a non--negative
fixnum representing the number of slots.
@end defun


@defun ccdoubles-real-vector-finalise @var{rvec}
Finalise @var{rvec}; return unspecified values.  It is fine to apply
this function multiple times to the same @var{rvec} value: the first
time the underlying data is finalised, the subsequent times nothing
happens.

If this function is applied to an @var{rvec} value not owning the
underlying data area: @var{rvec} is finalised, but the data area is left
alone.
@end defun

@c page
@node plain rvec access
@subsection Setters and getters


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector-ref @var{rvec} @var{idx}
Return a flonum object representing the value in the slot at index
@var{idx}.  If an error occurs: raise an exception.
@end defun


@defun ccdoubles-real-vector-set! @var{rvec} @var{idx} @var{flo}
Store the flonum object @var{flo} in the slot at index @var{idx},
overwriting the old value.  If an error occurs: raise an exception.
@end defun

@c page
@node plain rvec conversion
@subsection Object types conversion


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector->vector @var{rvec}
Return a Scheme vector object holding the elements of @var{rvec}.
@end defun


@defun vector->ccdoubles-real-vector @var{vec}
Return an instance of @objtype{ccdoubles-real-vector} holding the
elements of the Scheme vector @var{vec}.
@end defun


Conversion example:

@lisp
(define V    '#(1.2 3.4 5.6))
(define rvec (vector->ccdoubles-real-vector V))
(define V^   (ccdoubles-real-vector->vector rvec))
(equal? V V^)   @result{} #t
@end lisp

@c page
@node plain rvec basic
@subsection Basic vector operations


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector-clear @var{rvec}
Reset all the slots to @samp{0.0}.
@end defun


@defun ccdoubles-real-vector-set @var{rvec} @var{flo}
Set all the slots to the flonum @var{flo}.
@end defun


@defun ccdoubles-real-vector-copy @var{dst-rvec} @var{src-rvec}
Copy all the slots from the source vector @var{src-rvec} to the
destination vector @var{dst-rvec}.
@end defun

@c page
@node plain cvec
@section Complex vectors of flonums


@menu
* plain cvec struct::           Complex vector data type.
* plain cvec init::             Initialisation and finalisation.
* plain cvec access::           Setters and getters.
* plain cvec conversion::       Object types conversion.
@end menu

@c page
@node plain cvec struct
@subsection Complex vector data type


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@deftp {Struct Type} ccdoubles-cplx-vector
@cindex Argument @var{cvec}
@cindex @var{cvec} argument
Opaque structure type referencing a data area holding @samp{double}
precision flonums representing complex numbers.  Unless otherwise
specified, when instances of this type are used as arguments to
functions: this documentation identifies them as @var{cvec}.

Instances of this type must be finalised with
@func{ccdoubles-cplx-vector-finalise}; whenever an instance of this type
is garbage collected: @func{ccdoubles-cplx-vector-finalise} is
automatically applied to it and any error ignored.

In certain contexts, instances of this type own the underlying data
area, in other contexts they do not:

@itemize
@item
Finalising a @objtype{ccdoubles-cplx-vector} instance owning the data
area, causes finalisation of the data area too.

@item
Finalising a @objtype{ccdoubles-cplx-vector} instance @strong{not}
owning the data area, leaves the data area untouched.
@end itemize

@noindent
this should happen transparently.
@end deftp


@defun ccdoubles-cplx-vector? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-cplx-vector}; otherwise return @false{}.
@end defun


@defun ccdoubles-cplx-vector?/alive @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-cplx-vector} and it has not been finalised; return
@false{} otherwise.
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun ccdoubles-cplx-vector-putprop @var{cvec} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{cvec};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun ccdoubles-cplx-vector-getprop @var{cvec} @var{key}
Return the value of the property @var{key} in the property list of
@var{cvec}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun ccdoubles-cplx-vector-remprop @var{cvec} @var{key}
Remove the property @var{key} from the property list of @var{cvec}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun ccdoubles-cplx-vector-property-list @var{cvec}
Return a new association list representing the property list of
@var{cvec}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Custom destructor


@defun alpha-custom-destructor @var{cvec}
@defunx set-alpha-custom-destructor! @var{cvec} @var{func}
Retrieve or set a destructor function associated to @var{cvec}.

Whenever @var{cvec} is finalised, either explicitly with
@func{ccdoubles-cplx-vector-finalise} or implicitly by the garbage
collector, @var{func} is applied to @var{cvec} before the internal state
of @var{cvec} is destroyed.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun ccdoubles-cplx-vector-hash @var{cvec}
Return an exact integer to be used as hashtable key for @var{cvec}.
Hashtables having a @objtype{ccdoubles-cplx-vector} as key can be instantiated
as follows:

@example
(make-hashtable ccdoubles-cplx-vector-hash eq?)
@end example
@end defun

@c page
@node plain cvec init
@subsection Initialisation and finalisation


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-cplx-vector-initialise @var{nslots}
Build and return a new @objtype{ccdoubles-cplx-vector} object; if an
error occurs raise an exception.  @var{nslots} must be a non--negative
fixnum representing the number of slots.
@end defun


@defun ccdoubles-cplx-vector-finalise @var{cvec}
Finalise @var{cvec}; return unspecified values.  It is fine to apply
this function multiple times to the same @var{cvec} value: the first
time the underlying data is finalised, the subsequent times nothing
happens.

If this function is applied to an @var{cvec} value not owning the
underlying data area: @var{cvec} is finalised, but the data area is left
alone.
@end defun

@c page
@node plain cvec access
@subsection Setters and getters


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector-ref @var{cvec} @var{idx}
Return a cflonum object representing the value in the slot at index
@var{idx}.  If an error occurs: raise an exception.
@end defun


@defun ccdoubles-real-vector-set! @var{cvec} @var{idx} @var{cnum}
Store the complex number object @var{cnum} in the slot at index
@var{idx}, overwriting the old value.  If an error occurs: raise an
exception.
@end defun

@c page
@node plain cvec conversion
@subsection Object types conversion


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-cplx-vector->vector @var{cvec}
Return a Scheme vector object holding the elements of @var{cvec}.
@end defun


@defun vector->ccdoubles-cplx-vector @var{vec}
Return an instance of @objtype{ccdoubles-cplx-vector} holding the
elements of the Scheme vector @var{vec}.
@end defun


Conversion example:

@lisp
(define V    '#(1.2+2.3i 3.4+4.5i 5.6+6.7i))
(define cvec (vector->ccdoubles-cplx-vector V))
(define V^   (ccdoubles-cplx-vector->vector cvec))
(equal? V V^)   @result{} #t
@end lisp

@c page
@node plain rmat
@section Real matrices of flonums


@menu
* plain rmat struct::           Real matrix data type.
* plain rmat init::             Initialisation and finalisation.
* plain rmat access::           Setters and getters.
* plain rmat conversion::       Object types conversion.
@end menu

@c page
@node plain rmat struct
@subsection Real matrix data type


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@deftp {Struct Type} ccdoubles-real-matrix
@cindex Argument @var{rmat}
@cindex @var{rmat} argument
Opaque structure type referencing a data area holding @samp{double}
precision flonums; every instance of this type represents a matrix in
row--major order.  Unless otherwise specified, when instances of this
type are used as arguments to functions: this documentation identifies
them as @var{rmat}.

Instances of this type must be finalised with
@func{ccdoubles-real-matrix-finalise}; whenever an instance of this type
is garbage collected: @func{ccdoubles-real-matrix-finalise} is
automatically applied to it and any error ignored.

In certain contexts, instances of this type own the underlying data
area, in other contexts they do not:

@itemize
@item
Finalising a @objtype{ccdoubles-real-matrix} instance owning the data
area, causes finalisation of the data area too.

@item
Finalising a @objtype{ccdoubles-real-matrix} instance @strong{not}
owning the data area, leaves the data area untouched.
@end itemize

@noindent
this should happen transparently.
@end deftp


@defun ccdoubles-real-matrix? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-real-matrix}; otherwise return @false{}.
@end defun


@defun ccdoubles-real-matrix?/alive @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-real-matrix} and it has not been finalised; return
@false{} otherwise.
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun ccdoubles-real-matrix-putprop @var{rmat} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{rmat};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun ccdoubles-real-matrix-getprop @var{rmat} @var{key}
Return the value of the property @var{key} in the property list of
@var{rmat}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun ccdoubles-real-matrix-remprop @var{rmat} @var{key}
Remove the property @var{key} from the property list of @var{rmat}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun ccdoubles-real-matrix-property-list @var{rmat}
Return a new association list representing the property list of
@var{rmat}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Custom destructor


@defun alpha-custom-destructor @var{rmat}
@defunx set-alpha-custom-destructor! @var{rmat} @var{func}
Retrieve or set a destructor function associated to @var{rmat}.

Whenever @var{rmat} is finalised, either explicitly with
@func{ccdoubles-real-matrix-finalise} or implicitly by the garbage
collector, @var{func} is applied to @var{rmat} before the internal state
of @var{rmat} is destroyed.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun ccdoubles-real-matrix-hash @var{rmat}
Return an exact integer to be used as hashtable key for @var{rmat}.
Hashtables having a @objtype{ccdoubles-real-matrix} as key can be instantiated
as follows:

@example
(make-hashtable ccdoubles-real-matrix-hash eq?)
@end example
@end defun

@c page
@node plain rmat init
@subsection Initialisation and finalisation


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-matrix-initialise @var{nrows} @var{ncols}
Build and return a new @objtype{ccdoubles-real-matrix} object; if an
error occurs raise an exception.  @var{nrows} and @var{ncols} must be a
non--negative fixnums representing the number of rows and columns.
@end defun


@defun ccdoubles-real-matrix-finalise @var{rmat}
Finalise @var{rmat}; return unspecified values.  It is fine to apply
this function multiple times to the same @var{rmat} value: the first
time the underlying data is finalised, the subsequent times nothing
happens.

If this function is applied to an @var{rmat} value not owning the
underlying data area: @var{rmat} is finalised, but the data area is left
alone.
@end defun

@c page
@node plain rmat access
@subsection Setters and getters


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector-ref @var{rmat} @var{row} @var{col}
Return a flonum object representing the value in the slot at row index
@var{row} and column index @var{col}.  If an error occurs: raise an
exception.
@end defun


@defun ccdoubles-real-vector-set! @var{rmat} @var{row} @var{col} @var{flo}
Store the flonum object @var{flo} in the slot at row index @var{row} and
column index @var{col}, overwriting the old value.  If an error occurs:
raise an exception.
@end defun

@c page
@node plain rmat conversion
@subsection Object types conversion


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-matrix->vector @var{rmat}
Return a Scheme vector object holding the elements of @var{rmat}, row
after row.
@end defun


@defun vector->ccdoubles-real-vector @var{nrows} @var{ncols} @var{vec}
Return an instance of @objtype{ccdoubles-real-vector}, with @var{nrows}
rows and @var{ncols} columns, holding the elements of the Scheme vector
@var{vec}.
@end defun


Conversion example:

@lisp
(define V      '#(1.1 1.2 1.3
                  2.1 2.2 2.3))
(define nrows  2)
(define ncols  3)
(define rmat   (vector->ccdoubles-real-matrix nrows ncols V))
(define V^     (ccdoubles-real-matrix->vector rmat))
(equal? V V^)   @result{} #t
@end lisp

@c page
@node plain cmat
@section Complex matrices of flonums


@menu
* plain cmat struct::           Complex matrix data type.
* plain cmat init::             Initialisation and finalisation.
* plain cmat access::           Setters and getters.
* plain cmat conversion::       Object types conversion.
@end menu

@c page
@node plain cmat struct
@subsection Complex matrix data type


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@deftp {Struct Type} ccdoubles-cplx-matrix
@cindex Argument @var{cmat}
@cindex @var{cmat} argument
Opaque structure type referencing a data area holding @samp{double}
precision flonums representing complex numbers; every instance of this
type represents a matrix in row--major order.  Unless otherwise
specified, when instances of this type are used as arguments to
functions: this documentation identifies them as @var{cmat}.

Instances of this type must be finalised with
@func{ccdoubles-cplx-matrix-finalise}; whenever an instance of this type
is garbage collected: @func{ccdoubles-cplx-matrix-finalise} is
automatically applied to it and any error ignored.

In certain contexts, instances of this type own the underlying data
area, in other contexts they do not:

@itemize
@item
Finalising a @objtype{ccdoubles-cplx-matrix} instance owning the data
area, causes finalisation of the data area too.

@item
Finalising a @objtype{ccdoubles-cplx-matrix} instance @strong{not}
owning the data area, leaves the data area untouched.
@end itemize

@noindent
this should happen transparently.
@end deftp


@defun ccdoubles-cplx-matrix? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-cplx-matrix}; otherwise return @false{}.
@end defun


@defun ccdoubles-cplx-matrix?/alive @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-cplx-matrix} and it has not been finalised; return
@false{} otherwise.
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun ccdoubles-cplx-matrix-putprop @var{cmat} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{cmat};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun ccdoubles-cplx-matrix-getprop @var{cmat} @var{key}
Return the value of the property @var{key} in the property list of
@var{cmat}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun ccdoubles-cplx-matrix-remprop @var{cmat} @var{key}
Remove the property @var{key} from the property list of @var{cmat}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun ccdoubles-cplx-matrix-property-list @var{cmat}
Return a new association list representing the property list of
@var{cmat}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Custom destructor


@defun alpha-custom-destructor @var{cmat}
@defunx set-alpha-custom-destructor! @var{cmat} @var{func}
Retrieve or set a destructor function associated to @var{cmat}.

Whenever @var{cmat} is finalised, either explicitly with
@func{ccdoubles-cplx-matrix-finalise} or implicitly by the garbage
collector, @var{func} is applied to @var{cmat} before the internal state
of @var{cmat} is destroyed.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun ccdoubles-cplx-matrix-hash @var{cmat}
Return an exact integer to be used as hashtable key for @var{cmat}.
Hashtables having a @objtype{ccdoubles-cplx-matrix} as key can be instantiated
as follows:

@example
(make-hashtable ccdoubles-cplx-matrix-hash eq?)
@end example
@end defun

@c page
@node plain cmat init
@subsection Initialisation and finalisation


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-cplx-matrix-initialise @var{nrows} @var{ncols}
Build and return a new @objtype{ccdoubles-cplx-matrix} object; if an
error occurs raise an exception.  @var{nrows} and @var{ncols} must be a
non--negative fixnums representing the number of rows and columns.
@end defun


@defun ccdoubles-cplx-matrix-finalise @var{cmat}
Finalise @var{cmat}; return unspecified values.  It is fine to apply
this function multiple times to the same @var{cmat} value: the first
time the underlying data is finalised, the subsequent times nothing
happens.

If this function is applied to an @var{cmat} value not owning the
underlying data area: @var{cmat} is finalised, but the data area is left
alone.
@end defun

@c page
@node plain cmat access
@subsection Setters and getters


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-real-vector-ref @var{cmat} @var{row} @var{col}
Return a flonum object representing the value in the slot at row index
@var{row} and column index @var{col}.  If an error occurs: raise an
exception.
@end defun


@defun ccdoubles-real-vector-set! @var{cmat} @var{row} @var{col} @var{flo}
Store the flonum object @var{flo} in the slot at row index @var{row} and
column index @var{col}, overwriting the old value.  If an error occurs:
raise an exception.
@end defun

@c page
@node plain cmat conversion
@subsection Object types conversion


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-cplx-matrix->vector @var{cmat}
Return a Scheme vector object holding the elements of @var{cmat}, row
after row.
@end defun


@defun vector->ccdoubles-cplx-vector @var{nrows} @var{ncols} @var{vec}
Return an instance of @objtype{ccdoubles-cplx-vector}, with @var{nrows}
rows and @var{ncols} columns, holding the elements of the Scheme vector
@var{vec}.
@end defun


Conversion example:

@lisp
(define V      '#(1.1+0.1i 1.2+0.1i 1.3+0.1i
                  2.1+0.1i 2.2+0.1i 2.3+0.1i))
(define nrows  2)
(define ncols  3)
(define cmat   (vector->ccdoubles-cplx-matrix nrows ncols V))
(define V^     (ccdoubles-cplx-matrix->vector cmat))
(equal? V V^)   @result{} #t
@end lisp

@c page
@node plain ivec
@section Real vectors of integers


Vectors of exact integers are used to represent the result of comparison
operations between vectors of real flonums: less than, greater than,
etc.

@menu
* plain ivec struct::           Integers vector data type.
* plain ivec init::             Initialisation and finalisation.
* plain ivec access::           Setters and getters.
* plain ivec conversion::       Object types conversion.
@end menu

@c page
@node plain ivec struct
@subsection Real vector data type


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@deftp {Struct Type} ccdoubles-int-vector
@cindex Argument @var{ivec}
@cindex @var{ivec} argument
Opaque structure type referencing a data area holding @samp{signed int}
values.  Unless otherwise specified, when instances of this type are
used as arguments to functions: this documentation identifies them as
@var{ivec}.

Instances of this type must be finalised with
@func{ccdoubles-int-vector-finalise}; whenever an instance of this type
is garbage collected: @func{ccdoubles-int-vector-finalise} is
automatically applied to it and any error ignored.

In certain contexts, instances of this type own the underlying data
area, in other contexts they do not:

@itemize
@item
Finalising a @objtype{ccdoubles-int-vector} instance owning the data
area, causes finalisation of the data area too.

@item
Finalising a @objtype{ccdoubles-int-vector} instance @strong{not}
owning the data area, leaves the data area untouched.
@end itemize

@noindent
this should happen transparently.
@end deftp


@defun ccdoubles-int-vector? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-int-vector}; otherwise return @false{}.
@end defun


@defun ccdoubles-int-vector?/alive @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-int-vector} and it has not been finalised; return
@false{} otherwise.
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun ccdoubles-int-vector-putprop @var{ivec} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{ivec};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun ccdoubles-int-vector-getprop @var{ivec} @var{key}
Return the value of the property @var{key} in the property list of
@var{ivec}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun ccdoubles-int-vector-remprop @var{ivec} @var{key}
Remove the property @var{key} from the property list of @var{ivec}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun ccdoubles-int-vector-property-list @var{ivec}
Return a new association list representing the property list of
@var{ivec}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Custom destructor


@defun alpha-custom-destructor @var{ivec}
@defunx set-alpha-custom-destructor! @var{ivec} @var{func}
Retrieve or set a destructor function associated to @var{ivec}.

Whenever @var{ivec} is finalised, either explicitly with
@func{ccdoubles-int-vector-finalise} or implicitly by the garbage
collector, @var{func} is applied to @var{ivec} before the internal state
of @var{ivec} is destroyed.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun ccdoubles-int-vector-hash @var{ivec}
Return an exact integer to be used as hashtable key for @var{ivec}.
Hashtables having a @objtype{ccdoubles-int-vector} as key can be instantiated
as follows:

@example
(make-hashtable ccdoubles-int-vector-hash eq?)
@end example
@end defun

@c page
@node plain ivec init
@subsection Initialisation and finalisation


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-int-vector-initialise @var{nslots}
Build and return a new @objtype{ccdoubles-int-vector} object; if an
error occurs raise an exception.  @var{nslots} must be a non--negative
fixnum representing the number of slots.
@end defun


@defun ccdoubles-int-vector-finalise @var{ivec}
Finalise @var{ivec}; return unspecified values.  It is fine to apply
this function multiple times to the same @var{ivec} value: the first
time the underlying data is finalised, the subsequent times nothing
happens.

If this function is applied to an @var{ivec} value not owning the
underlying data area: @var{ivec} is finalised, but the data area is left
alone.
@end defun

@c page
@node plain ivec access
@subsection Setters and getters


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-int-vector-ref @var{ivec} @var{idx}
Return a flonum object representing the value in the slot at index
@var{idx}.  If an error occurs: raise an exception.
@end defun


@defun ccdoubles-int-vector-set! @var{ivec} @var{idx} @var{flo}
Store the flonum object @var{flo} in the slot at index @var{idx},
overwriting the old value.  If an error occurs: raise an exception.
@end defun

@c page
@node plain ivec conversion
@subsection Object types conversion


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-int-vector->vector @var{ivec}
Return a Scheme vector object holding the elements of @var{ivec}.
@end defun


@defun vector->ccdoubles-int-vector @var{vec}
Return an instance of @objtype{ccdoubles-int-vector} holding the
elements of the Scheme vector @var{vec}.
@end defun


Conversion example:

@lisp
(define V     '#(1 2 3))
(define ivec  (vector->ccdoubles-int-vector V))
(define V^    (ccdoubles-int-vector->vector ivec))
(equal? V V^)   @result{} #t
@end lisp

@c page
@node plain imat
@section Real matrices of integers


Matrices of exact integers are used to represent the result of
comparison operations between matrices of real flonums: less than,
greater than, etc.

@menu
* plain imat struct::           Real matrix data type.
* plain imat init::             Initialisation and finalisation.
* plain imat access::           Setters and getters.
* plain imat conversion::       Object types conversion.
@end menu

@c page
@node plain imat struct
@subsection Real matrix data type


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@deftp {Struct Type} ccdoubles-int-matrix
@cindex Argument @var{imat}
@cindex @var{imat} argument
Opaque structure type referencing a data area holding @samp{signed int}
values; every instance of this type represents a matrix in row--major
order.  Unless otherwise specified, when instances of this type are used
as arguments to functions: this documentation identifies them as
@var{imat}.

Instances of this type must be finalised with
@func{ccdoubles-int-matrix-finalise}; whenever an instance of this type
is garbage collected: @func{ccdoubles-int-matrix-finalise} is
automatically applied to it and any error ignored.

In certain contexts, instances of this type own the underlying data
area, in other contexts they do not:

@itemize
@item
Finalising a @objtype{ccdoubles-int-matrix} instance owning the data
area, causes finalisation of the data area too.

@item
Finalising a @objtype{ccdoubles-int-matrix} instance @strong{not}
owning the data area, leaves the data area untouched.
@end itemize

@noindent
this should happen transparently.
@end deftp


@defun ccdoubles-int-matrix? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-int-matrix}; otherwise return @false{}.
@end defun


@defun ccdoubles-int-matrix?/alive @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{ccdoubles-int-matrix} and it has not been finalised; return
@false{} otherwise.
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun ccdoubles-int-matrix-putprop @var{imat} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{imat};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun ccdoubles-int-matrix-getprop @var{imat} @var{key}
Return the value of the property @var{key} in the property list of
@var{imat}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun ccdoubles-int-matrix-remprop @var{imat} @var{key}
Remove the property @var{key} from the property list of @var{imat}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun ccdoubles-int-matrix-property-list @var{imat}
Return a new association list representing the property list of
@var{imat}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Custom destructor


@defun alpha-custom-destructor @var{imat}
@defunx set-alpha-custom-destructor! @var{imat} @var{func}
Retrieve or set a destructor function associated to @var{imat}.

Whenever @var{imat} is finalised, either explicitly with
@func{ccdoubles-int-matrix-finalise} or implicitly by the garbage
collector, @var{func} is applied to @var{imat} before the internal state
of @var{imat} is destroyed.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun ccdoubles-int-matrix-hash @var{imat}
Return an exact integer to be used as hashtable key for @var{imat}.
Hashtables having a @objtype{ccdoubles-int-matrix} as key can be instantiated
as follows:

@example
(make-hashtable ccdoubles-int-matrix-hash eq?)
@end example
@end defun

@c page
@node plain imat init
@subsection Initialisation and finalisation


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-int-matrix-initialise @var{nrows} @var{ncols}
Build and return a new @objtype{ccdoubles-int-matrix} object; if an
error occurs raise an exception.  @var{nrows} and @var{ncols} must be a
non--negative fixnums representing the number of rows and columns.
@end defun


@defun ccdoubles-int-matrix-finalise @var{imat}
Finalise @var{imat}; return unspecified values.  It is fine to apply
this function multiple times to the same @var{imat} value: the first
time the underlying data is finalised, the subsequent times nothing
happens.

If this function is applied to an @var{imat} value not owning the
underlying data area: @var{imat} is finalised, but the data area is left
alone.
@end defun

@c page
@node plain imat access
@subsection Setters and getters


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-int-vector-ref @var{imat} @var{row} @var{col}
Return a flonum object representing the value in the slot at row index
@var{row} and column index @var{col}.  If an error occurs: raise an
exception.
@end defun


@defun ccdoubles-int-vector-set! @var{imat} @var{row} @var{col} @var{flo}
Store the flonum object @var{flo} in the slot at row index @var{row} and
column index @var{col}, overwriting the old value.  If an error occurs:
raise an exception.
@end defun

@c page
@node plain imat conversion
@subsection Object types conversion


The following bindings are exported by the library
@value{FOREIGN_SCHEME_LIB}.


@defun ccdoubles-int-matrix->vector @var{imat}
Return a Scheme vector object holding the elements of @var{imat}, row
after row.
@end defun


@defun vector->ccdoubles-int-vector @var{nrows} @var{ncols} @var{vec}
Return an instance of @objtype{ccdoubles-int-vector}, with @var{nrows}
rows and @var{ncols} columns, holding the elements of the Scheme vector
@var{vec}.
@end defun


Conversion example:

@lisp
(define V      '#(1 2 3
                  4 5 6))
(define nrows  2)
(define ncols  3)
(define imat   (vector->ccdoubles-int-matrix nrows ncols V))
(define V^     (ccdoubles-int-matrix->vector imat))
(equal? V V^)   @result{} #t
@end lisp

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest version of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the home page of the Vicare project is at:

@center @value{VICARE_HOMEPAGE_URL}

@noindent
@value{FOREIGN_PACKAGE} can be found here:

@center @value{FOREIGN_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

